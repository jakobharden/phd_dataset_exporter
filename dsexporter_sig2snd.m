## Export selected signal data to sound file (compression- or shear wave signals)#### FUNCTION SYNOPSIS:#### Usage 1: [r_of] = dsexporter_sig2snd(p_ss, p_odp, p_ifp, p_cn, p_si, p_ff, p_fs)##                     non-interactive mode#### Usage 2: [r_of] = dsexporter_sig2snd(p_ss, p_odp, p_ifp, p_cn, p_si, p_ff, [])##                     non-interactive mode##                     use fallback value for sampling rate from settings file#### Usage 3: [r_of] = dsexporter_sig2snd(p_ss, p_odp, p_ifp, p_cn, p_si, [], p_fs)##                     non-interactive mode##                     use fallback value for sound file format from settings file#### Usage 5: [r_of] = dsexporter_sig2snd(p_ss, p_odp, p_ifp, p_cn, [], p_ff, p_fs)##                     interactive mode##                     show signal selection dialogue, GUI#### Usage 6: [r_of] = dsexporter_sig2snd(p_ss, p_odp, p_ifp, [], p_si, p_ff, p_fs)##                     interactive mode##                     show channel selection dialogue, GUI#### Usage 7: [r_of] = dsexporter_sig2snd(p_ss, p_odp, [], p_cn, p_si, p_ff, p_fs)##                     interactive mode##                     show dataset file selection dialogue, GUI#### Usage 8: [r_of] = dsexporter_sig2snd(p_ss, [], p_ifp, p_cn, p_si, p_ff, p_fs)##                     non-interactive mode##                     use fallback value for output directory path (p_odp = "./tmp")#### Usage 9: [r_of] = dsexporter_sig2snd([], p_odp, p_ifp, p_cn, p_si, p_ff, p_fs)##                     non-interactive mode##                     load default export settings (see also: dsexporter_settings.m)#### p_ss  ... export settings data structure, optional, <struct_export_settings>## p_odp ... output directory path, optional, default = "./tmp" <str>## p_ifp ... dataset data structure or full qualified file path to dataset file, optional, <struct_dataset> or <str>## p_cn  ... channel number, optional, <uint>##            1: channel 1, compression wave, logitudinal##            2: channel 2, shear wave, transversal##            3: both channels, compression- and shear wave## p_si  ... signal index or signal index array, optional, <uint> or [<uint>]## p_ff  ... export file format, optional, default = 'wav', <str>## p_fs  ... sampling rate in Hz, optional, default = 15000, <uint>## r_of ... return: sound file output file path(s), <str> or {<str>}#### Supported file formats: see GNU octave command "audioformats" for available output file formats#### see also: tool_gui_dsload.m, tool_gui_selsig.m, tool_gui_selchn.m, dsexporter_substruct.m, tool_get_maturity.m, audioformats#### Copyright 2023 Jakob Harden (jakob.harden@tugraz.at, Graz University of Technology, Graz, Austria)## License: MIT## This file is part of the PhD thesis of Jakob Harden.## ## Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated ## documentation files (the “Software”), to deal in the Software without restriction, including without ## limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of ## the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:## ## THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ## THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ## AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, ## TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.##function [r_of] = dsexporter_sig2snd(p_ss, p_odp, p_ifp, p_cn, p_si, p_ff, p_fs)    ## check arguments  if (nargin < 1)    p_ss = [];  endif  if (nargin < 2)    p_odp = [];  endif  if (nargin < 3)    p_ifp = [];  endif  if (nargin < 4)    p_cn = [];  endif  if (nargin < 5)    p_si = [];  endif  if (nargin < 6)    p_ff = [];  endif  if (nargin < 7)    p_fs = [];  endif    ## init return values  r_of = {};    ## load settings  if isempty(p_ss)    p_ss = dsexporter_settings();  endif    ## set default values  if isempty(p_odp)    p_ss.temp.odp = p_ss.dir_tmp_default;  else    p_ss.temp.odp = p_odp;  endif  if isempty(p_ff)    p_ss.temp.sndfmt = p_ss.sound_format_default;  else    p_ss.temp.sndfmt = p_ff;  endif  if isempty(p_fs)    p_ss.temp.sndfs = p_ss.sound_samplingrate_default;  else    p_ss.temp.sndfs = p_fs;  endif    ## load dataset  ds = tool_gui_dsload(p_ifp);    ## select channel  cn = tool_gui_selchn(p_cn);    ## maturity  ma_sec = tool_get_maturity(ds, cn, 'sec');  ma_min = tool_get_maturity(ds, cn, 'min');    ## select signal id(s)  si = tool_gui_selsig(ma_min, p_si);    ## test series name, sound file metadata  p_ss.temp.tsname = dsexporter_substruct(p_ss, ds, 'meta_ser_code').v;    ## dataset code, part of file name  p_ss.temp.dscode = dsexporter_substruct(p_ss, ds, 'meta_set_code').v;    ## time code, part of file name  p_ss.temp.tmcode = strftime('%Y%m%d%H%M%S', localtime(time()));    ## extract signal data, write CSV file(s)  r_of = {};  switch (cn)    case 1      ## channel 1, compression wave, longitudinal      ## channel name, part of file name      p_ss.temp.chname1 = 'c';      p_ss.temp.chname2 = 'C-wave (1)';      ## signal magnitude matrix      ms = dsexporter_substruct(p_ss, ds, 'tst.utt1.ms').v;      ## export sound file, mono      [r_of] = hlp_write_sound_mono(p_ss, ms, p_si);    case 2      ## channel 2, shear wave, transversal      ## channel name, part of file name      p_ss.temp.chname1 = 's';      p_ss.temp.chname2 = 'S-wave (2)';      ## signal magnitude matrix      ms = dsexporter_substruct(p_ss, ds, 'tst.utt2.ms').v;      ## export sound file, mono      [r_of] = hlp_write_sound_mono(p_ss, ms, p_si);    case 3      ## channel 1 and 2, compression and shear wave, longitudinal and transversal      ## channel name, part of file name      p_ss.temp.chname1 = 'cs';      p_ss.temp.chname2 = 'C/S-wave (1,2)';      ## signal magnitude matrix, channel 1, compression wave      ms1 = dsexporter_substruct(p_ss, ds, 'tst.utt1.ms').v;      ## signal magnitude matrix, channel 2, shear wave      ms2 = dsexporter_substruct(p_ss, ds, 'tst.utt2.ms').v;      ## export sound file, stereo      [r_of] = hlp_write_sound_stereo(p_ss, ms1, ms2, p_si);    otherwise      help dsexporter_sig2snd;      error('Channel selection number %d is not defined!', cn);  endswitch  endfunctionfunction [r_of] = hlp_write_sound_mono(p_ss, p_ms, p_si)  ## Write sound file, mono  ##  ## p_ss ... settings data structure, <struct_dsexporter_settings>  ## p_ms ... sample magnitude matrix, compression or shear wave, [[<dbl>]]  ## p_si ... signal index or signal index array, <uint> or [<uint>]  ## r_of ... return: output file path, <str> or {<str>}    ## write signal data to sound files  r_of = {};  for sid = p_si    ## output file name    if (p_ss.fn_append_tmcode)      ofn = sprintf('%s_sig_%s_%d_%s.%s', p_ss.temp.dscode, p_ss.temp.chname1, sid, p_ss.temp.tmcode, p_ss.temp.sndfmt);    else      ofn = sprintf('%s_sig_%s_%d.%s', p_ss.temp.dscode, p_ss.temp.chname1, sid, p_ss.temp.sndfmt);    endif        ## metadata, title    meta_title = sprintf('%s, dataset: %s, channel: %s, signal id: %d', p_ss.temp.tsname, p_ss.temp.dscode, p_ss.temp.chname2, sid);        ## output file path    ofp = fullfile(p_ss.temp.odp, ofn);        ## normalize sound wave    ms = p_ms(:, sid);    ms = ms ./ max(abs(ms));        ## write sound file    audiowrite(ofp, ms(:), p_ss.temp.sndfs, ...      'BitsPerSample', p_ss.sound_bitdepth, 'Quality', p_ss.sound_quality, 'Title', meta_title, ...      'Artist', p_ss.sound_meta_artist, 'Comment', p_ss.sound_meta_comment);        ## collect output file paths    r_of = [r_of; ofp];  endfor  endfunctionfunction [r_of] = hlp_write_sound_stereo(p_ss, p_ms1, p_ms2, p_si)  ## Write sound file, stereo  ##  ## p_ss  ... settings data structure, <struct_dsexporter_settings>  ## p_ms1 ... sample magnitude matrix, compression wave, [[<dbl>]]  ## p_ms2 ... sample magnitude matrix, shear wave, [[<dbl>]]  ## p_si  ... signal index or signal index array, <uint> or [<uint>]  ## r_of  ... return: output file path, <str> or {<str>}    ## write signal data to sound files  r_of = {};  for sid = p_si    ## output file name    if (p_ss.fn_append_tmcode)      ofn = sprintf('%s_sig_%s_%d_%s.%s', p_ss.temp.dscode, p_ss.temp.chname1, sid, p_ss.temp.tmcode, p_ss.temp.sndfmt);    else      ofn = sprintf('%s_sig_%s_%d.%s', p_ss.temp.dscode, p_ss.temp.chname1, sid, p_ss.temp.sndfmt);    endif        ## metadata, title    meta_title = sprintf('%s, dataset: %s, channel: %s, signal id: %d', p_ss.temp.tsname, p_ss.temp.dscode, p_ss.temp.chname2, sid);        ## output file path    ofp = fullfile(p_ss.temp.odp, ofn);        ## normalize sound wave    ms1 = p_ms1(:, sid);    ms1 = ms1 ./ max(abs(ms1));    ms2 = p_ms2(:, sid);    ms2 = ms2 ./ max(abs(ms2));        ## write sound file    audiowrite(ofp, [ms1, ms2], p_ss.temp.sndfs, ...      'BitsPerSample', p_ss.sound_bitdepth, 'Quality', p_ss.sound_quality, 'Title', meta_title, ...      'Artist', p_ss.sound_meta_artist, 'Comment', p_ss.sound_meta_comment);        ## collect output file paths    r_of = [r_of; ofp];  endfor  endfunction